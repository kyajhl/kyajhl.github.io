<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千里之行, 始于足下</title>
  
  <subtitle>温故而知新</subtitle>
  <link href="https://kyajhl.github.io/atom.xml" rel="self"/>
  
  <link href="https://kyajhl.github.io/"/>
  <updated>2023-09-08T07:01:01.765Z</updated>
  <id>https://kyajhl.github.io/</id>
  
  <author>
    <name>kefan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jvm</title>
    <link href="https://kyajhl.github.io/posts/jvm/"/>
    <id>https://kyajhl.github.io/posts/jvm/</id>
    <published>2023-09-08T00:49:29.000Z</published>
    <updated>2023-09-08T07:01:01.765Z</updated>
    
    
    
    
    <category term="学习笔记" scheme="https://kyajhl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="jvm" scheme="https://kyajhl.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="https://kyajhl.github.io/posts/linux/"/>
    <id>https://kyajhl.github.io/posts/linux/</id>
    <published>2023-09-04T06:41:49.000Z</published>
    <updated>2023-09-04T07:18:38.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><h2 id="1、查找功能"><a href="#1、查找功能" class="headerlink" title="1、查找功能"></a>1、查找功能</h2><h3 id="（1）、匹配"><a href="#（1）、匹配" class="headerlink" title="（1）、匹配"></a>（1）、匹配</h3><ul><li><p>片段匹配</p><ol><li>从上往下找，比如“hello”：&#x2F;hello</li><li>从下往上找，比如”hello“：?hello</li></ol></li><li><p>精确匹配</p><p>如果你输入“&#x2F;the”，你也可能找到“three“。</p><ol><li>只匹配单词开头：&#x2F;\&lt;the</li><li>只匹配单词结尾：&#x2F;the\&gt;</li><li>完整匹配单词：&#x2F;\&lt;the\&gt;</li></ol></li></ul><h3 id="（2）、正则表达式"><a href="#（2）、正则表达式" class="headerlink" title="（2）、正则表达式"></a>（2）、正则表达式</h3><ol><li>”.“：通配一个字符，如匹配server，可以用&#x2F;se…r，一个”.“只匹配一个字符</li><li>”*“：统配多个字符，如匹配server，可以用s*r，一个”*“可以匹配多个字符</li></ol><h3 id="（3）、快速查找"><a href="#（3）、快速查找" class="headerlink" title="（3）、快速查找"></a>（3）、快速查找</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vim编辑器&quot;&gt;&lt;a href=&quot;#vim编辑器&quot; class=&quot;headerlink&quot; title=&quot;vim编辑器&quot;&gt;&lt;/a&gt;vim编辑器&lt;/h1&gt;&lt;h2 id=&quot;1、查找功能&quot;&gt;&lt;a href=&quot;#1、查找功能&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://kyajhl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux" scheme="https://kyajhl.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://kyajhl.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kyajhl.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-09-03T10:23:43.000Z</published>
    <updated>2023-09-11T12:33:57.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><h2 id="1、什么是模式？"><a href="#1、什么是模式？" class="headerlink" title="1、什么是模式？"></a>1、什么是模式？</h2><p>模式就是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案</p><h2 id="2、模式的作用"><a href="#2、模式的作用" class="headerlink" title="2、模式的作用"></a>2、模式的作用</h2><p>高效、快速的解决应用问题</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1、设计模式包含什么"><a href="#1、设计模式包含什么" class="headerlink" title="1、设计模式包含什么"></a>1、设计模式包含什么</h2><p>设计模式一般包含模式名称、问题、解决方案、效果等组成要素</p><ul><li>模式名称：通过一两个词来描述模式的问题、解决方案和效果、以便更好理解模式和方便开发人员交流、绝大多数模式都是根据其功能或模式结构来命名的</li><li>问题：描述了应该在何时使用模式，包含了设计中存在的问题以及问题存在的原因</li><li>解决方案：描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述</li><li>效果：描述了模式的优缺点以及在使用模式时应该权衡的问题</li></ul><h2 id="2、设计模式分为几种"><a href="#2、设计模式分为几种" class="headerlink" title="2、设计模式分为几种"></a>2、设计模式分为几种</h2><p>设计模式（23种）可分为<strong>创建型</strong>，<strong>结构型</strong>和<strong>行为型</strong>三种</p><ul><li>创建型模式（5种）：主要用于描述如何创建对象</li><li>结构型模式（7种）：主要用于描述如何实现类或对象的组合</li><li>行为型模式（11种）：主要用于描述类或对象怎样交互以及怎样分配职责</li></ul><blockquote><p>此外，根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为<strong>类模式</strong>和<strong>对象模式</strong>，我们经常将两种分类模式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为模式</p></blockquote><h3 style="color: red">"简单工厂模式"并不在23种设计模式之中</h3><h2 id="3、设计模式有什么用"><a href="#3、设计模式有什么用" class="headerlink" title="3、设计模式有什么用"></a>3、设计模式有什么用</h2><ol><li>设计模式来源众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作，也许我们冥思苦想得到的一个“自以为很了不起”的设计方案其实就是某一个设计模式。在时间就是金钱的今天，设计模式无疑会为有助于我们提高开发和设计效率，但它不保证一定会提高</li><li>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为我们节省不少时间。无论你使用哪种编程语言，做什么类型的项目，甚至你处于一个国际化的开发团队，当面对同一个设计模式时，你和别人的理解并无二异，因为设计模式是跨语言、跨平台、跨应用、跨国界的</li><li>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。此外，随着软件规模的日益增大，软件寿命的日益变长，系统的可维护性和可扩展性也越来越重要，许多设计模式将有助于提高系统的灵活性和可扩展性，让我们在不修改或者少修改现有系统的基础上增加、删除或者替换功能模块。如果一点设计模式都不懂，我想要做到这一点恐怕还是很困难的</li><li>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。如果某一天因为升职或跳槽等原因，别人接手了你的项目，只要他也懂设计模式，我想他应该能够很快理解你的设计思路和实现方案，让你升职无后患之忧，跳槽也心安理得，何乐而不为呢？</li><li>最后一点对初学者很重要，学习设计模式将有助于初学者更加深入地理解面向对象思想，让你知道：如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如果不修改源代码增加新功能？同时还让你能够更好地阅读和理解现有类库（如JDK）与其他系统中的源代码，让你早点脱离面向对象编程的“菜鸟期”</li></ol><blockquote><p>个人观点：</p><ul><li>掌握设计模式并不是件很难的事情，关键在于多思考，多实践，不要听到人家说懂几个设计模式就很“牛”，只要用心学习，设计模式也就那么回事，你也可以很“牛”的，一定要有信心</li><li>在学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。当你能够回答上述所有问题时，恭喜你，你了解一个设计模式了，至于掌握它，那就在开发中去使用吧，用多了你自然就掌握了</li><li>“如果想体验一下运用模式的感觉，那么最好的方法就是运用它们”。设计模式是“内功心法”，它还是要与“实战招式”相结合才能够相得益彰。学习设计模式的目的在于应用，如果不懂如何使用一个设计模式，而只是学过，能够说出它的用途，绘制它的结构，充其量也只能说你了解这个模式，严格一点说：不会在开发中灵活运用一个模式基本上等于没学。所以一定要做到：少说多做</li><li>千万不要滥用模式，不要试图在一个系统中用上所有的模式，也许有这样的系统，但至少目前我没有碰到过。每个模式都有自己的适用场景，不能为了使用模式而使用模式？滥用模式不如不用模式，因为滥用的结果得不到“艺术品”一样的软件，很有可能是一堆垃圾代码</li><li>如果将设计模式比喻成“三十六计”，那么每一个模式都是一种计策，它为解决某一类问题而诞生，不管这个设计模式的难度如何，使用频率高不高，我建议大家都应该好好学学，多学一个模式也就意味着你多了“一计”，说不定什么时候一不小心就用上了。因此，模式学习之路上要不怕困难，勇于挑战，有的模式虽然难一点，但反复琢磨，反复研读，应该还是能够征服的</li><li>设计模式的“上乘”境界：“手中无模式，心中有模式”。模式使用的最高境界是你已经不知道具体某个设计模式的定义和结构了，但你会灵活自如地选择一种设计方案【其实就是某个设计模式】来解决某个问题，设计模式已经成为你开发技能的一部分，能够手到擒来，“内功”与“招式”已浑然一体，要达到这个境界并不是看完某本书或者开发一两个项目就能够实现的，它需要不断沉淀与积累，所以，对模式的学习不要急于求成</li></ul></blockquote><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</p><p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句</p><p><strong>常见的7种面向对象设计原则</strong></p><table><thead><tr><th>设计原则名称</th><th>定义</th><th>使用频率</th></tr></thead><tbody><tr><td>单一职责原则</td><td>一个类只负责一个功能领域中的相应职责</td><td>★★★★☆</td></tr><tr><td>开闭原则</td><td>软件实体应对扩展开放，而对修改关闭</td><td>★★★★★</td></tr><tr><td>里氏代换原则</td><td>所有引用基类对象的地方能够透明地使用其子类的对象</td><td>★★★★★</td></tr><tr><td>依赖倒转原则</td><td>抽象不应该依赖于细节，细节应该依赖于抽象</td><td>★★★★★</td></tr><tr><td>接口隔离原则</td><td>使用多个专门的接口，而不使用单一的总接口</td><td>★★☆☆☆</td></tr><tr><td>合成复用原则</td><td>尽量使用对象组合，而不是继承来达到复用的目的</td><td>★★★★☆</td></tr><tr><td>迪米特法则</td><td>一个软件实体应当尽可能少地与其他实体发生相互作用</td><td>★★★☆☆</td></tr></tbody></table><h2 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h2><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.jpg" alt="1"></p><p>如图所示的一个类，类中的方法说明如下：<code>getConnection()</code>方法用于连接数据库，<code>findCustomers()</code>用于查询所有的客户信息，<code>createChart()</code>用于创建图表，<code>displayChart()</code>用于显示图表。</p><p><code>CustomerDataChart</code>类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用<code>findCustomers()</code>方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类<code>CustomerDataChart</code>可拆分为如下三个类：</p><ol><li><code>DBUtil</code>：负责连接数据库，包含数据库连接方法<code>getConnection()</code></li><li><code>CustomerDAO</code>：负责操作数据库中的Customer表，包含对<code>Customer</code>表的增删改查等方法，如<code>findCustomers()</code></li><li><code>CustomerDataChart</code>：负责图表的生成和显示，包含方法<code>createChart()</code>和<code>displayChart()</code></li></ol><p>使用单一职责原则，重构后的结构如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.jpg" alt="2"></p><h2 id="2、开闭原则"><a href="#2、开闭原则" class="headerlink" title="2、开闭原则"></a>2、开闭原则</h2><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.jpg" alt="3"></p><p>如图所示，在<code>ChartDisplay</code>类的<code>display()</code>方法中存在以下片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">&quot;pie&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">PieChart</span> <span class="variable">pieChart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PieChart</span>();</span><br><span class="line">    pieChart.display();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;bar&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">BarChart</span> <span class="variable">barChart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BarChart</span>();</span><br><span class="line">barChart.display();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>在该代码中，如果需要增加一个新的图表类，如折线图<code>LineChart</code>，则需要修改<code>ChartDisplay</code>类的<code>display()</code>方法的源代码，增加新的判断逻辑，违反了开闭原则。</p><p>现对该系统进行重构，使之符合开闭原则。</p><p>在本实例中，由于在<code>ChartDisplay</code>类的<code>display()</code>方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：</p><ol><li>增加一个抽象图表类<code>AbstractChart</code>，将各种具体图表类作为其子类</li><li><code>ChartDisplay</code>类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表</li></ol><p>重构后的结构如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.jpg" alt="4"></p><p>我们引入了抽象图表类<code>AbstractChart</code>，且<code>ChartDisplay</code>针对抽象图表类进行编程，并通过<code>setChart()</code>方法由客户端来设置实例化的具体图表对象，在<code>ChartDisplay</code>的<code>display()</code>方法中调用<code>chart</code>对象的<code>display()</code>方法显示图表。如果需要增加一种新的图表，如折线图<code>LineChart</code>，只需要将<code>LineChart</code>也作为<code>AbstractChart</code>的子类，在客户端向<code>ChartDisplay</code>中注入一个<code>LineChart</code>对象即可，无须修改现有类库的源代码</p><h2 id="3、里氏代换原则"><a href="#3、里氏代换原则" class="headerlink" title="3、里氏代换原则"></a>3、里氏代换原则</h2><p>定义：<strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong></p><p>里氏代换原则告诉我们，<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象</strong>。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong></p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.jpg" alt="5"></p><p>如上图所示，客户(Customer)可以分为VIP客户(<code>VIPCustomer</code>)和普通客户(<code>CommonCustomer</code>)两类，系统需要提供一个发送Email的功能</p><p>在对系统进行进一步分析后发现，无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个<code>send()</code>方法中的代码重复，而且在本系统中还将增加新类型的客户。为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.jpg" alt="6"></p><p>重构之后，新增加一个<code>Customer</code>类作为<code>CommonCustomer</code>和<code>VIPCustomer</code>的抽象类，邮件发送类<code>EmailSender</code>针对抽象客户类<code>Customer</code>编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将<code>EmailSender</code>中的<code>send()</code>方法的参数类型改为<code>Customer</code>，如果需要增加新类型的客户，只需将其作为<code>Customer</code>类的子类即可</p><h2 id="4、依赖倒转原则"><a href="#4、依赖倒转原则" class="headerlink" title="4、依赖倒转原则"></a>4、依赖倒转原则</h2><p>定义：<em><strong>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程</strong></em></p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.jpg" alt="7"></p><p>如上图所示，每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将<code>TXTDataConvertor</code>改为<code>ExcelDataConvertor</code>，此时，需要修改<code>CustomerDAO</code>的源代码，而且在引入并使用新的数据转换类时也不得不修改<code>CustomerDAO</code>的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构</p><p>重构后如下图：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.jpg" alt="8"></p><p>由于<code>CustomerDAO</code>针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改<code>CustomerDAO</code>的源代码。我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类<code>DataConvertor</code>之后，<code>CustomerDAO</code>针对抽象类<code>DataConvertor</code>编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换<code>ataConvertor</code>类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为<code>DataConvertor</code>的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则</p><p><em><strong>重点</strong></em></p><blockquote><p>在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，<strong>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段</strong>，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已</p></blockquote><h2 id="5、接口隔离原则"><a href="#5、接口隔离原则" class="headerlink" title="5、接口隔离原则"></a>5、接口隔离原则</h2><p>定义：<em><strong>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</strong></em></p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.jpg" alt="9"></p><p>如上图所示，方法<code>dataRead()</code>用于从文件中读取数据，方法<code>transformToXML()</code>用于将数据转换成XML格式，方法<code>createChart()</code>用于创建图表，方法<code>displayChart()</code>用于显示图表，方法<code>createReport()</code>用于创建文字报表，方法<code>displayReport()</code>用于显示文字报表。</p><p>在实际使用过程中发现该接口很不灵活，例如如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的<code>transformToXML()</code>方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。现使用接口隔离原则对其进行重构</p><p>重构后如下图：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.jpg" alt="10"></p><p><em><strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便</strong></em></p><h2 id="6、合成复用原则"><a href="#6、合成复用原则" class="headerlink" title="6、合成复用原则"></a>6、合成复用原则</h2><p>定义：<em><strong>尽量使用对象组合，而不是继承来达到复用的目的</strong></em></p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.jpg" alt="11"></p><p>如上图所示，与数据库操作有关的类如<code>CustomerDAO</code>类等都需要连接数据库，连接数据库的方法<code>getConnection()</code>封装在<code>DBUtil</code>类中，由于需要重用<code>DBUtil</code>类的<code>getConnection()</code>方法，设计人员将<code>CustomerDAO</code>作为<code>DBUtil</code>类的子类</p><p>随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的<code>OracleDBUtil</code>类来连接Oracle数据库，由于在初始设计方案中<code>CustomerDAO</code>和<code>DBUtil</code>之间是继承关系，因此在更换数据库连接方式时需要修改<code>CustomerDAO</code>类的源代码，将<code>CustomerDAO</code>作为<code>OracleDBUtil</code>的子类，这将违反开闭原则，现使用合成复用原则对其进行重构</p><p>重构后如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.jpg" alt="12"></p><p>根据合成复用原则，我们在实现复用时应该多用关联，少用继承。因此在本实例中我们可以使用关联复用来取代继承复用。<code>CustomerDAO</code>和<code>DBUtil</code>之间的关系由继承关系变为关联关系，采用依赖注入的方式将<code>DBUtil</code>对象注入到<code>CustomerDAO</code>中，可以使用构造注入，也可以使用 <strong>Setter</strong> 注入。如果需要对<code>DBUtil</code>的功能进行扩展，可以通过其子类来实现，如通过子类<code>OracleDBUtil</code>来连接Oracle数据库。由于<code>CustomerDAO</code>针对<code>DBUtil</code>编程，根据里氏代换原则，<code>DBUtil</code>子类的对象可以覆盖<code>DBUtil</code>对象，只需在<code>CustomerDAO</code>中注入子类对象即可使用子类所扩展的方法。例如在<code>CustomerDAO</code>中注入<code>OracleDBUtil</code>对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式</p><h2 id="7、迪米特法则"><a href="#7、迪米特法则" class="headerlink" title="7、迪米特法则"></a>7、迪米特法则</h2><p>定义：<em><strong>一个软件实体应当尽可能少地与其他实体发生相互作用</strong></em></p><p>迪米特法则要求我们在设计系统时，<em><strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度</strong></em>。</p><p>在将迪米特法则运用到系统设计中时，要注意下面的几点：<em><strong>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低</strong></em>。</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.jpg" alt="13"></p><p>如上图所示，当一个按钮(<code>Button</code>)被单击时，对应的列表框(<code>List</code>)、组合框(<code>ComboBox</code>)、文本框(<code>TextBox</code>)、文本标签(<code>Label</code>)等都将发生改变。由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件，现使用迪米特对其进行重构</p><p>重构后如下图：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.jpg" alt="14"></p><p>在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类(<code>Mediator</code>)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码</p><h1 id="6个创建型模式"><a href="#6个创建型模式" class="headerlink" title="6个创建型模式"></a>6个创建型模式</h1><h2 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h2><h3 id="1-、图表库的设计"><a href="#1-、图表库的设计" class="headerlink" title="(1)、图表库的设计"></a>(1)、图表库的设计</h3><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chart</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String type; <span class="comment">//图表类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Chart</span><span class="params">(Object[][] data, String type)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.type = type;</span><br><span class="line"><span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;histogram&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//初始化柱状图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;pie&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//初始化饼状图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;line&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//初始化折线图</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.type.equalsIgnoreCase(<span class="string">&quot;histogram&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//显示柱状图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.type.equalsIgnoreCase(<span class="string">&quot;pie&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//显示饼状图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.type.equalsIgnoreCase(<span class="string">&quot;line&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//显示折线图</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码通过调用Chart类的构造函数来创建图表对象，根据参数type的不同可以得到不同类型的图表，然后再调用display()方法来显示相应的图表。不难看出，Chart类是一个“巨大的”类，在该类的设计中存在如下几个问题：</p><p>   (1) 在Chart类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。</p><p>   (2) Chart类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。</p><p>   (3) 当需要增加新类型的图表时，必须修改Chart类的源代码，违反了“开闭原则”。</p><p>   (4) 客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离。</p><p>   (5) 客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在Chart类的构造函数中没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建Chart对象时都会出现，导致代码的重复。</p><p><em><strong>*为什么需要工厂呢？有什么作用？*</strong></em></p><p>在Java语言中，我们通常有以下几种创建对象的方式：</p><ol><li>使用new关键字直接创建对象</li><li>通过反射机制创建对象</li><li>通过clone()方法创建对象</li><li>通过工厂类创建对象</li></ol><blockquote><p>在所有的工厂模式中，我们都强调一点：<em><strong>两个类A和B之间的关系应该仅仅是A创建B或是A使用B，而不能两种关系都有</strong></em>。将对象的创建和使用分离，也使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护</p><p> 此外，将对象的创建和使用分离还有一个好处：<em><strong>防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中</strong></em></p></blockquote><h3 id="2-、简单工厂模式概述"><a href="#2-、简单工厂模式概述" class="headerlink" title="(2)、简单工厂模式概述"></a>(2)、简单工厂模式概述</h3><p>定义：<em><strong>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式</strong></em></p><p>简单工厂模式结构比较简单，其核心是工厂类的设计，如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.jpg" alt="15"></p><p>简单工厂模式结构图中包含如下几个角色：</p><ul><li><strong><code>Factory</code></strong>(工厂角色)：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法<code>factoryMethod()</code>，它的返回类型为抽象产品类型<code>Product</code></li><li><strong><code>Product</code></strong>(抽象产品角色)：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象</li><li><strong><code>ConcreteProduct</code></strong>(具体产品角色)：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法</li></ul><p>在使用简单工厂模式时，首先需要对产品类进行重构，<strong>不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构</strong>，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//所有产品类的公共业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String arg)</span> &#123;</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">product = <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">product = <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">Product product; </span><br><span class="line">product = Factory.getProduct(<span class="string">&quot;A&quot;</span>); <span class="comment">//通过工厂类创建产品对象</span></span><br><span class="line">product.methodSame();</span><br><span class="line">product.methodDiff();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-、图表库的简单工厂模式解决方案"><a href="#3-、图表库的简单工厂模式解决方案" class="headerlink" title="(3)、图表库的简单工厂模式解决方案"></a>(3)、图表库的简单工厂模式解决方案</h3><p>为了将<code>Chart</code>类的职责分离，同时将<code>Chart</code>对象的创建和使用分离，Sunny软件公司开发人员决定使用简单工厂模式对图表库进行重构，重构后的结构如图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.jpg" alt="16"></p><p><code>Chart</code>接口充当抽象产品类，其子类<code>HistogramChart</code>、<code>PieChart</code>和<code>LineChart</code>充当具体产品类，<code>ChartFactory</code>充当工厂类。完整代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象图表接口：抽象产品类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Chart</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//柱状图类：具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HistogramChart</span> <span class="keyword">implements</span> <span class="title class_">Chart</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HistogramChart</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;创建柱状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示柱状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//饼状图类：具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PieChart</span> <span class="keyword">implements</span> <span class="title class_">Chart</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PieChart</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;创建饼状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示饼状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//折线图类：具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineChart</span> <span class="keyword">implements</span> <span class="title class_">Chart</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LineChart</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;创建折线图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示折线图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//图表工厂类：工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChartFactory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Chart <span class="title function_">getChart</span><span class="params">(String type)</span> &#123;</span><br><span class="line"><span class="type">Chart</span> <span class="variable">chart</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;histogram&quot;</span>)) &#123;</span><br><span class="line">chart = <span class="keyword">new</span> <span class="title class_">HistogramChart</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;初始化设置柱状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;pie&quot;</span>)) &#123;</span><br><span class="line">chart = <span class="keyword">new</span> <span class="title class_">PieChart</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;初始化设置饼状图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;line&quot;</span>)) &#123;</span><br><span class="line">chart = <span class="keyword">new</span> <span class="title class_">LineChart</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;初始化设置折线图！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chart;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写如下客户端测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">Chart chart;</span><br><span class="line">chart = ChartFactory.getChart(<span class="string">&quot;histogram&quot;</span>); <span class="comment">//通过静态工厂方法创建产品</span></span><br><span class="line">chart.display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建柱状图！</span><br><span class="line">初始化设置柱状图！</span><br><span class="line">显示柱状图！</span><br></pre></td></tr></table></figure><p>在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码：<code>chart = ChartFactory.getChart(&quot;histogram&quot;);</code> 改为 <code>chart = ChartFactory.getChart(&quot;pie&quot;);</code> 编译并运行程序，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建饼状图！</span><br><span class="line">初始化设置饼状图！</span><br><span class="line">显示饼状图！</span><br></pre></td></tr></table></figure><h3 id="4-、图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结"><a href="#4-、图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结" class="headerlink" title="(4)、图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结"></a>(4)、图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结</h3><p>在创建具体Chart对象时，每更换一个Chart对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。</p><p>我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下 <code>config.xml</code> 所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">chartType</span>&gt;</span>histogram<span class="tag">&lt;/<span class="name">chartType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再通过一个工具类 <code>XMLUtil</code> 来读取配置文件中的字符串参数，<code>XMLUtil</code> 类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取图表类型，并返回类型名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getChartType</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文档对象</span></span><br><span class="line"><span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line"><span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">Document doc;</span><br><span class="line">doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;config.xml&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取包含图表类型的文本节点</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;chartType&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">chartType</span> <span class="operator">=</span> classNode.getNodeValue().trim();</span><br><span class="line">            <span class="keyword">return</span> chartType;</span><br><span class="line">        &#125;   </span><br><span class="line">       <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引入了配置文件和工具类 <code>XMLUtil</code> 之后，客户端代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">Chart chart;</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> XMLUtil.getChartType(); <span class="comment">//读取配置文件中的参数</span></span><br><span class="line">chart = ChartFactory.getChart(type); <span class="comment">//创建产品对象</span></span><br><span class="line">chart.display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件 <code>config.xml</code> ，无须修改任何源代码，符合 <em><strong>开闭原则</strong></em></p><p>有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.jpg" alt="17"></p><h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><h3 id="1-、日志记录器的设计"><a href="#1-、日志记录器的设计" class="headerlink" title="(1)、日志记录器的设计"></a>(1)、日志记录器的设计</h3><p>简单工厂模式虽然简单，但存在一个很严重的问题。<em><strong>当系统中需要引入新产品时</strong></em>，由于静态工厂方法通过所传入参数的不同来<em><strong>创建不同的产品</strong></em>，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.jpg" alt="18"></p><p>如上图所示，<code>LoggerFactory</code>充当创建日志记录器的工厂，提供了工厂方法<code>createLogger()</code>用于创建日志记录器，<code>Logger</code>是抽象日志记录器接口，其子类为具体日志记录器。其中，工厂类<code>LoggerFactory</code>代码片段如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志记录器工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(args.equalsIgnoreCase(<span class="string">&quot;db&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//连接数据库，代码省略</span></span><br><span class="line"><span class="comment">//创建数据库日志记录器对象</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line"><span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(args.equalsIgnoreCase(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//创建日志文件</span></span><br><span class="line"><span class="comment">//创建文件日志记录器对象</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(); </span><br><span class="line"><span class="comment">//初始化文件日志记录器，代码省略</span></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了突出设计重点，我们对上述代码进行了简化，省略了具体日志记录器类的初始化代码。在<code>LoggerFactory</code>类中提供了静态工厂方法<code>createLogger()</code>，用于根据所传入的参数创建各种不同类型的日志记录器。通过使用简单工厂模式，我们将日志记录器对象的创建和使用分离，客户端只需使用由工厂类创建的日志记录器对象即可，无须关心对象的创建过程，但是我们发现，虽然简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题：</p><ol><li>工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大</li><li>系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”</li></ol><h3 id="2-、工厂方法模式概述"><a href="#2-、工厂方法模式概述" class="headerlink" title="(2)、工厂方法模式概述"></a>(2)、工厂方法模式概述</h3><p>在工厂方法模式中，我们<strong>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构</strong></p><p>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.jpg" alt="19"></p><p>如上图所示，工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象</p><p>在工厂方法模式结构图中包含如下几个角色：</p><ul><li><em><strong>Product（抽象产品）：</strong></em>它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类</li><li><em><strong><code>ConcreteProduct</code>（具体产品）：</strong></em>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应</li><li><em><strong>Factory（抽象工厂）：</strong></em>在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口</li><li><em><strong><code>ConcreteFactory</code>（具体工厂）：</strong></em>它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例</li></ul><p>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品，其典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。</p><p>在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，典型的客户端类代码片段如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">Factory factory;</span><br><span class="line">factory = <span class="keyword">new</span> <span class="title class_">ConcreteFactory</span>(); <span class="comment">//可通过配置文件实现</span></span><br><span class="line">Product product;</span><br><span class="line">product = factory.factoryMethod();</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h3 id="3-、日志记录器的工厂方法模式解决方案，反射与配置文件"><a href="#3-、日志记录器的工厂方法模式解决方案，反射与配置文件" class="headerlink" title="(3)、日志记录器的工厂方法模式解决方案，反射与配置文件"></a>(3)、日志记录器的工厂方法模式解决方案，反射与配置文件</h3><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.jpg" alt="20"></p><p>如上图所示，<code>Logger</code>接口充当抽象产品，其子类<code>FileLogger</code>和<code>DatabaseLogger</code>充当具体产品，<code>LoggerFactory</code>接口充当抽象工厂，其子类<code>FileLoggerFactory</code>和<code>DatabaseLoggerFactory</code>充当具体工厂。完整代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志记录器接口：抽象产品</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//数据库日志记录器：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;数据库日志记录。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//文件日志记录器：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;文件日志记录。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//日志记录器工厂接口：抽象工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//数据库日志记录器工厂类：具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//连接数据库，代码省略</span></span><br><span class="line"><span class="comment">//创建数据库日志记录器对象</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line"><span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//文件日志记录器工厂类：具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件日志记录器对象</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(); </span><br><span class="line"><span class="comment">//创建文件，代码省略</span></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编写如下客户端测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">LoggerFactory factory;</span><br><span class="line">Logger logger;</span><br><span class="line">factory = <span class="keyword">new</span> <span class="title class_">FileLoggerFactory</span>(); <span class="comment">//可引入配置文件实现</span></span><br><span class="line">logger = factory.createLogger();</span><br><span class="line">logger.writeLog();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件日志记录。</span><br></pre></td></tr></table></figure><p>为了让系统具有更好的灵活性和可扩展性，在客户端代码中将不再使用new关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（如XML文件）中，通过读取配置文件获取类名字符串，再使用Java的反射机制，根据类名字符串生成对象</p><p>为了读取该配置文件并通过存储在其中的类名字符串反射生成对象，一个名为<code>XMLUtil</code>的工具类，其详细代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工具类XMLUtil.java</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line"><span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建DOM文档对象</span></span><br><span class="line"><span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line"><span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">Document doc;</span><br><span class="line">doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;config.xml&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取包含类名的文本节点</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            Node classNode=nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String cName=classNode.getNodeValue();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class c=Class.forName(cName);</span><br><span class="line">      Object obj=c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<code>XMLUtil</code>类后，可以对日志记录器的客户端代码进行修改，不再直接使用new关键字来创建具体的工厂类，而是将具体工厂类的类名存储在XML文件中，再通过<code>XMLUtil</code>类的静态工厂方法<code>getBean()</code>方法进行对象的实例化，代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">LoggerFactory factory;</span><br><span class="line">Logger logger;</span><br><span class="line">factory = (LoggerFactory)XMLUtil.getBean(); <span class="comment">//getBean()的返回类型为Object，需要进行强制类型转换</span></span><br><span class="line">logger = factory.createLogger();</span><br><span class="line">logger.writeLog();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入<code>XMLUtil</code>类和XML配置文件后，如果要增加新的日志记录方式，只需要执行如下几个步骤：</p><ol><li>新的日志记录器需要继承抽象日志记录器Logger</li><li>对应增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂<code>LoggerFactory</code>，并实现其中的工厂方法<code>createLogger()</code>，设置好初始化参数和环境变量，返回具体日志记录器对象</li><li>修改配置文件<code>config.xml</code>，将新增的具体日志记录器工厂类的类名字符串替换原有工厂类类名字符串</li><li>编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合“开闭原则”</li></ol><p>通过上述重构可以使得系统更加灵活，由于很多设计模式都关注系统的可扩展性和灵活性，因此都定义了抽象层，在抽象层中声明业务方法，而将业务方法的实现放在实现层中</p><h3 id="4-、重载的工厂方法，工厂方法的隐藏，工厂方法模式总结"><a href="#4-、重载的工厂方法，工厂方法的隐藏，工厂方法模式总结" class="headerlink" title="(4)、重载的工厂方法，工厂方法的隐藏，工厂方法模式总结"></a>(4)、重载的工厂方法，工厂方法的隐藏，工厂方法模式总结</h3><p>通过进一步分析，发现可以通过多种方式来初始化日志记录器，例如可以为各种日志记录器提供默认实现；还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；也可以将参数封装在一个Object类型的对象中，通过Object对象将配置参数传入工厂类。此时，可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。当然，对于同一个具体工厂而言，无论使用哪个工厂方法，创建的产品类型均要相同</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21.jpg" alt="21"></p><p>如上图所示，引入重载方法后，抽象工厂<code>LoggerFactory</code>的代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span>;</span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂类<code>DatabaseLoggerFactory</code>代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//使用默认方式连接数据库，代码省略</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line"><span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span> &#123;</span><br><span class="line"><span class="comment">//使用参数args作为连接字符串来连接数据库，代码省略</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line"><span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="comment">//使用封装在参数obj中的连接字符串来连接数据库，代码省略</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line"><span class="comment">//使用封装在参数obj中的数据来初始化数据库日志记录器，代码省略</span></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//其他具体工厂类代码省略</span></span><br></pre></td></tr></table></figure><p>有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时，在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。</p><p>如果对客户端隐藏工厂方法，日志记录器的结构图将修改为下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.jpg" alt="22"></p><p>抽象工厂类<code>LoggerFactory</code>的代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改为抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="comment">//在工厂类中直接调用日志记录器类的业务方法writeLog()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="built_in">this</span>.createLogger();</span><br><span class="line">logger.writeLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">LoggerFactory factory;</span><br><span class="line">factory = (LoggerFactory)XMLUtil.getBean();</span><br><span class="line">factory.writeLog(); <span class="comment">//直接使用工厂对象来调用产品对象的业务方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和<code>API</code>类库的核心模式</p><p><em><strong>主要优点</strong></em></p><ol><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”</li></ol><p><em><strong>主要缺点</strong></em></p><ol><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度</li></ol><p><em><strong>适用场景</strong></em></p><ol><li>客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中</li><li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展</li></ol><h2 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h2><h3 id="1-、界面皮肤库的初始设计"><a href="#1-、界面皮肤库的初始设计" class="headerlink" title="(1)、界面皮肤库的初始设计"></a>(1)、界面皮肤库的初始设计</h3><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23.jpg" alt="23"></p><p>如上图所示，欲开发一套界面皮肤库，可以对Java桌面软件进行界面美化。为了保护版权，该皮肤库源代码不打算公开，而只向用户提供已打包为jar文件的class字节码文件。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。</p><p>针对上述要求，决定使用工厂方法模式进行系统的设计，为了保证系统的灵活性和可扩展性，提供一系列具体工厂来创建按钮、文本框、组合框等界面元素，客户端针对抽象工厂编程，初始结构如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/24.jpg" alt="24"></p><p>上图中，提供了大量工厂来创建具体的界面组件，可以通过配置文件更换具体界面组件从而改变界面风格。但是，此设计方案存在如下问题：</p><ol><li>当需要增加新的皮肤时，虽然不要修改现有代码，但是需要增加大量类，针对每一个新增具体组件都需要增加一个具体工厂，类的个数成对增加，这无疑会导致系统越来越庞大，增加系统的维护成本和运行开销</li><li>由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置，如果某个具体工厂选择失误将会导致界面显示混乱，虽然我们可以适当增加一些约束语句，但客户端代码和配置文件都较为复杂</li></ol><h3 id="2-、产品等级结构与产品族"><a href="#2-、产品等级结构与产品族" class="headerlink" title="(2)、产品等级结构与产品族"></a>(2)、产品等级结构与产品族</h3><ol><li><em><strong>产品等级结构</strong></em>：<em><strong>产品等级结构即产品的继承结构</strong></em>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类</li><li><em><strong>产品族</strong></em>：在抽象工厂模式中，<em><strong>产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品</strong></em>，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族</li></ol><p>产品等级结构与产品族示意图如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25.jpg" alt="25"></p><p>不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。上图中一共有五个产品族，分属于三个不同的产品等级结构。我们只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一确定这个产品</p><p>当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26.jpg" alt="26"></p><p>在上图中，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，图4所示结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大减少了系统中类的个数</p><h3 id="3-、抽象工厂模式概述"><a href="#3-、抽象工厂模式概述" class="headerlink" title="(3)、抽象工厂模式概述"></a>(3)、抽象工厂模式概述</h3><p>抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂<em><strong>不只是创建一种产品</strong></em>，它负责创建一族产品。抽象工厂模式定义如下：</p><p><em><strong>抽象工厂模式(Abstract Factory Pattern)<em><strong>：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为</strong></em>Kit</strong></em>模式，它是一种对象创建型模式</p><p>在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如下图所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/27.jpg" alt="27"></p><p>在抽象工厂模式结构图中包含如下几个角色：</p><ol><li><em><strong><code>AbstractFactory</code></strong></em>(抽象工厂)：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品</li><li><em><strong><code>ConcreteFactory</code></strong></em>(具体工厂)：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中</li><li><em><strong><code>AbstractProduct</code></strong></em>(抽象产品)：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</li><li><em><strong><code>ConcreteProduct</code></strong></em>(具体产品)：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法</li></ol><p>在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>; <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>; <span class="comment">//工厂方法二</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//工厂方法二</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式对产品对象进行创建</p><h3 id="4-、界面皮肤库的抽象工厂模式解决方案"><a href="#4-、界面皮肤库的抽象工厂模式解决方案" class="headerlink" title="(4)、界面皮肤库的抽象工厂模式解决方案"></a>(4)、界面皮肤库的抽象工厂模式解决方案</h3><p>对界面皮肤库设计方案如下所示：</p><p><img src="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/28.jpg" alt="28"></p><p><code>SkinFactory</code>接口充当抽象工厂，其子类<code>SpringSkinFactory</code>和<code>SummerSkinFactory</code>充当具体工厂，接口<code>Button</code>、<code>TextField</code>和<code>ComboBox</code>充当抽象产品，其子类<code>SpringButton</code>、<code>SpringTextField</code>、<code>SpringComboBox</code>和<code>SummerButton</code>、<code>SummerTextField</code>、<code>SummerComboBox</code>充当具体产品。完整代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在本实例中我们对代码进行了大量简化，实际使用时，界面组件的初始化代码较为复杂，还需要使用JDK中一些已有类，为了突出核心代码，在此只提供框架代码和演示输出。</span></span><br><span class="line"><span class="comment">//按钮接口：抽象产品</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring按钮类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示浅绿色按钮。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Summer按钮类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SummerButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示浅蓝色按钮。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//文本框接口：抽象产品</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring文本框类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示绿色边框文本框。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Summer文本框类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SummerTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示蓝色边框文本框。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//组合框接口：抽象产品</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring组合框类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringComboBox</span> <span class="keyword">implements</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示绿色边框组合框。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Summer组合框类：具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SummerComboBox</span> <span class="keyword">implements</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;显示蓝色边框组合框。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//界面皮肤工厂接口：抽象工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> ComboBox <span class="title function_">createComboBox</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring皮肤工厂：具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringSkinFactory</span> <span class="keyword">implements</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringButton</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringTextField</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> ComboBox <span class="title function_">createComboBox</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringComboBox</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Summer皮肤工厂：具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SummerSkinFactory</span> <span class="keyword">implements</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerButton</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerTextField</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> ComboBox <span class="title function_">createComboBox</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerComboBox</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让系统具备良好的灵活性和可扩展性，我们引入了工具类<code>XMLUtil</code>和配置文件，其中，<code>XMLUtil</code>类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line"><span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//创建文档对象</span></span><br><span class="line"><span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line"><span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">Document doc;</span><br><span class="line">doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;config.xml&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取包含类名的文本节点</span></span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            Node classNode=nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String cName=classNode.getNodeValue();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class c=Class.forName(cName);</span><br><span class="line">      Object obj=c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件<code>config.xml</code>中存储了具体工厂类的类名，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">&lt;className&gt;SpringSkinFactory&lt;/className&gt;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure><p>编写如下客户端测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">//使用抽象层定义</span></span><br><span class="line">SkinFactory factory;</span><br><span class="line">Button bt;</span><br><span class="line">TextField tf;</span><br><span class="line">ComboBox cb;</span><br><span class="line">factory = (SkinFactory)XMLUtil.getBean();</span><br><span class="line">bt = factory.createButton();</span><br><span class="line">tf = factory.createTextField();</span><br><span class="line">cb = factory.createComboBox();</span><br><span class="line">bt.display();</span><br><span class="line">tf.display();</span><br><span class="line">cb.display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序，输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">显示浅绿色按钮。</span><br><span class="line">显示绿色边框文本框。</span><br><span class="line">显示绿色边框组合框。</span><br></pre></td></tr></table></figure><p>如果需要更换皮肤，只需修改配置文件即可，在实际环境中，我们可以<em><strong>提供可视化界面，例如菜单或者窗口来修改配置文件，用户无须直接修改配置文件</strong></em>。如果需要增加新的皮肤，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件即可使用新的皮肤，原有代码无须修改，符合“开闭原则”</p><h3 id="5-、“开闭原则”的倾斜性，抽象工厂模式总结"><a href="#5-、“开闭原则”的倾斜性，抽象工厂模式总结" class="headerlink" title="(5)、“开闭原则”的倾斜性，抽象工厂模式总结"></a>(5)、“开闭原则”的倾斜性，抽象工厂模式总结</h3><p>抽象工厂模式设计了界面皮肤库，该皮肤库可以较为方便地增加新的皮肤，但是现在遇到一个非常严重的问题：由于设计时考虑不全面，忘记为单选按钮(<code>RadioButton</code>)提供不同皮肤的风格化显示，导致无论选择哪种皮肤，单选按钮都显得那么“格格不入”。Sunny公司的设计人员决定向系统中增加单选按钮，但是发现原有系统居然不能够在符合“开闭原则”的前提下增加新的组件，原因是抽象工厂<code>SkinFactory</code>中根本没有提供创建单选按钮的方法，如果需要增加单选按钮，首先需要修改抽象工厂接口<code>SkinFactory</code>，在其中新增声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的皮肤中创建单选按钮，此外还需要修改客户端，否则单选按钮无法应用于现有系统。</p><p>怎么办？答案是抽象工厂模式无法解决该问题，这也是抽象工厂模式最大的缺点。在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p><ol><li><strong>增加产品族</strong>：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改</li><li><strong>增加新的产品等级结构</strong>：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”</li></ol><p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦</p><p><em><strong>主要优点</strong></em></p><ol><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li><li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”</li></ol><p><em><strong>主要缺点</strong></em></p><ol><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”</li></ol><p><em><strong>适用场景</strong></em></p><ol><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型</li><li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li></ol><h2 id="4、单例模式"><a href="#4、单例模式" class="headerlink" title="4、单例模式"></a>4、单例模式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模式&quot;&gt;&lt;a href=&quot;#模式&quot; class=&quot;headerlink&quot; title=&quot;模式&quot;&gt;&lt;/a&gt;模式&lt;/h1&gt;&lt;h2 id=&quot;1、什么是模式？&quot;&gt;&lt;a href=&quot;#1、什么是模式？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是模式？&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://kyajhl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://kyajhl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://kyajhl.github.io/posts/redis/"/>
    <id>https://kyajhl.github.io/posts/redis/</id>
    <published>2023-09-03T02:39:00.000Z</published>
    <updated>2023-10-06T12:50:10.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-10大数据类型"><a href="#Redis-10大数据类型" class="headerlink" title="Redis 10大数据类型"></a>Redis 10大数据类型</h1><p>10大数据类型包括：<strong>String</strong>(字符串)，<strong>Bitmap</strong>(位图)，<strong>Bitfield</strong>(位域)，<strong>Hash</strong>(哈希表)，<strong>List</strong>(集合)，<strong>Set</strong>(列表)，<strong>Sorted set</strong>(有序集合 ZSet)，<strong>Geospatial</strong>(地理空间)，<strong>Hyperlog</strong>(基数统计)，<strong>Stream</strong>(流)</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol><li><code>keys *</code>：查看当前库所有的 <em>key</em> </li><li><code>exists [key...]</code>：判断某个 <em>key</em> 是否存在，返回的数字为存在的 <em>key</em> 数量</li><li><code>type key</code>：查看 <em>key</em> 是什么类型</li><li><code>del [key...]</code>：删除指定的 <em>key</em> 数据，返回的数字为删除的 <em>key</em> 数量（原子性，若key很大，则在高并发情况下会产生阻塞队列）</li><li><code>unlink [key...]</code>：非阻塞删除，会在异步中操作（非阻塞，异步操作，不会产生阻塞队列）</li><li><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li><code>expire key</code>：为给定的 <em>key</em> 设置过期时间</li><li><code>move key dbindex[0-15]</code>：将当前数据库的 <em>key</em> 移动到给定的数据库 <em>db</em> 当中，<em>dbindex</em> 直接输入数字即可</li><li><code>select dbindex</code>：切换数据库[0-15]，默认为 0</li><li><code>dbsize</code>：查看当前数据库 <em>key</em> 的数量</li><li><code>flushdb</code>：清空当前库（很危险，尽量不要使用）</li><li><code>flushall</code>：通杀全部库（更危险，最好不要使用）</li></ol><p>备注：</p><blockquote><p>命令不区分大小写，而 <em>key</em> 区分大小写</p><p>永远的帮助命令，help @类型，如help @String，help @List，help @Hash</p></blockquote><h1 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h1><h2 id="1、set命令"><a href="#1、set命令" class="headerlink" title="1、set命令"></a>1、set命令</h2><ol><li><code>set key value [nx|xx]</code>：*<code>nx</code><em>表示 <em>key</em> 不存在时 <em>set</em> ，</em><code>xx</code>*表示 <em>key</em> 存在时 <em>set</em>，若不符合情况，均返回 <em>null</em></li><li><code>set key value [get]</code>：*<code>get</code>*表示会返回<strong>老值</strong>，同时设置<strong>新值</strong>，若 <em>key</em> 不存在则返回 <em>null</em></li><li><code>set key value [ex seconds|px milliseconds] </code>：*<code>ex seconds</code>* 以秒为单位设置过期时间，*<code>px milliseconds</code>* 以毫秒为单位设置过期时间</li><li><code>set key value [exat unix-time-seconds|pxat unix-time-milliseconds]</code>：*<code>exat unix-time-seconds</code>* 设置以秒为单位的<em>unix</em> 时间戳所对应的时间为过期时间，*<code>pxat unix-time-milliseconds</code>* 设置以毫秒为单位的 <em>unix</em> 时间戳所对应的时间为过期时间</li><li><code>set key value [keepttl]</code>：*<code>keepttl</code>* 保留设置前指定键的生存时间，这样在修改了 <em>key</em> 值后也不会丢失原来的过期时间</li></ol><h2 id="2、mset、mget和msetnx命令"><a href="#2、mset、mget和msetnx命令" class="headerlink" title="2、mset、mget和msetnx命令"></a>2、mset、mget和msetnx命令</h2><ol><li><code>mset key value [key value ...]</code>：同时设置多个键值</li><li><code>mget key [key ...]</code>：同时获取多个键值</li><li><code>msetnx key value [key value ...]</code>：只有不存在键，才能设置值，并且是同时设置，即使只有一个不存在，也不能设置值</li></ol><h2 id="3、getrange和setrange命令"><a href="#3、getrange和setrange命令" class="headerlink" title="3、getrange和setrange命令"></a>3、getrange和setrange命令</h2><ol><li><code>getrange key start end</code>：相当于 <em>Java</em> 中的 <code>subString</code> ，可以截取范围内的字符串</li><li><code>setrange key offset value</code>：从 <em>offset</em> 开始，用 <em>value</em> 覆盖原来的值，<em>value</em> 有多少位，就覆盖多少位</li></ol><h2 id="4、incr、incrby、decr和decrby命令"><a href="#4、incr、incrby、decr和decrby命令" class="headerlink" title="4、incr、incrby、decr和decrby命令"></a>4、incr、incrby、decr和decrby命令</h2><ol><li><code>incr key</code>：递增数字</li><li><code>incrby key increment</code>：增加指定的整数</li><li><code>decr key</code>：递减数字</li><li><code>decrby key decrement</code>：减少指定的整数</li></ol><h2 id="5、strlen和append命令"><a href="#5、strlen和append命令" class="headerlink" title="5、strlen和append命令"></a>5、strlen和append命令</h2><ol><li><code>strlen key</code>：获取字符串长度</li><li><code>append key value</code>：往键值追加指定内容 <em>value</em></li></ol><h2 id="6、setex和setnx命令-分布式锁"><a href="#6、setex和setnx命令-分布式锁" class="headerlink" title="6、setex和setnx命令(分布式锁)"></a>6、setex和setnx命令(分布式锁)</h2><ol><li><code>setex key seconds value</code>：给 <em>key</em> 设置过期时间和值</li><li><code>setnx key value</code>：只有当 <em>key</em> 不存在时，才会设置值</li></ol><h2 id="7、getset命令"><a href="#7、getset命令" class="headerlink" title="7、getset命令"></a>7、getset命令</h2><ol><li><code>getset key value</code>：先 <em>get</em> ，再 <em>set</em> ，和 <code>set key value get</code> 一致</li></ol><h1 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h1><h2 id="1、lpush、rpush和lrange命令"><a href="#1、lpush、rpush和lrange命令" class="headerlink" title="1、lpush、rpush和lrange命令"></a>1、lpush、rpush和lrange命令</h2><ol><li><code>lpush key element [element ...]</code>：给 <em>key</em> 设置一系列值，并且是从左插入，和链表类似</li><li><code>rpush key element [element ...]</code>：给 <em>key</em> 设置一系列值，并且是从右插入，和链表类似</li><li><code>lrange key start stop</code>：<em>list</em> 类型独有的遍历方式，<em>start</em> 和 <em>stop</em> 取下标，<em>stop</em> 为 -1 时表示遍历<strong>全部</strong></li></ol><h2 id="2、lpop和rpop命令"><a href="#2、lpop和rpop命令" class="headerlink" title="2、lpop和rpop命令"></a>2、lpop和rpop命令</h2><ol><li><code>lpop key [count]</code>：从左开始弹出 <em>key</em> 对应 <em>count</em> 个值，返回的是弹出的值</li><li><code>rpop key [count]</code>：从右开始弹出 <em>key</em> 对应 <em>count</em> 个值，返回的是弹出的值</li></ol><h2 id="3、lindex和llen命令"><a href="#3、lindex和llen命令" class="headerlink" title="3、lindex和llen命令"></a>3、lindex和llen命令</h2><ol><li><code>lindex key index</code>：获取 <em>index</em> 对应的值</li><li><code>llen key</code>：获取列表中元素的个数</li></ol><h2 id="4、lrem和ltrim命令"><a href="#4、lrem和ltrim命令" class="headerlink" title="4、lrem和ltrim命令"></a>4、lrem和ltrim命令</h2><ol><li><code>lrem key count element</code>：删除 <em>count</em> 个值等于 <em>element</em> 的元素</li><li><code>ltrim key start stop</code>：截取指定范围内的值后再赋值给 <em>key</em></li></ol><h2 id="5、rpoplpush命令"><a href="#5、rpoplpush命令" class="headerlink" title="5、rpoplpush命令"></a>5、rpoplpush命令</h2><ol><li><code>rpoplpush source destination</code>：对 <em>surce</em> 执行 <code>rpop</code> 操作后，把 <strong>弹出的元素</strong> 再 <code>lpush</code> 到 <em>destination</em></li></ol><h2 id="6、lset和linsert命令"><a href="#6、lset和linsert命令" class="headerlink" title="6、lset和linsert命令"></a>6、lset和linsert命令</h2><ol><li><code>lset key index element</code>：设置对应 <em>index</em> 位置的元素值为 <em>element</em></li><li><code>linsert key before|after pivot element</code>：在对应 <em>pivot</em> 值的位置前|后，插入 <em>element</em> 值</li></ol><h1 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h1><h2 id="1、hset、hget、hmset、hmget、hgetall和hdel命令"><a href="#1、hset、hget、hmset、hmget、hgetall和hdel命令" class="headerlink" title="1、hset、hget、hmset、hmget、hgetall和hdel命令"></a>1、hset、hget、hmset、hmget、hgetall和hdel命令</h2><ol><li><code>hset key field value [field value ...]</code>：设置 <em>key</em> 对应的键值对，可以设置多个</li><li><code>hget key field</code>：获取 <em>key</em> 对应的键的值</li><li><code>hmset key field value [field value ...]</code>：和 <code>hset</code> 用法差不多</li><li><code>hmget key field [field ...]</code>：可以获取 <em>key</em> 多个键的值</li><li><code>hgetall key</code>：可以获取 <em>key</em> 对应的多个键值对</li><li><code>hdel key field [field ...]</code>：删除 <em>key</em> 多个键</li></ol><h2 id="2、hlen命令"><a href="#2、hlen命令" class="headerlink" title="2、hlen命令"></a>2、hlen命令</h2><ol><li><code>hlen key</code>：获取 <em>key</em> 全部键的个数</li></ol><h2 id="3、hexists-命令"><a href="#3、hexists-命令" class="headerlink" title="3、hexists 命令"></a>3、hexists 命令</h2><ol><li><code>hexists key field</code>：判断 <em>key</em> 对应的键是否存在，若存在则返回 1，不存在返回 0</li></ol><h2 id="4、hkeys和hvals命令"><a href="#4、hkeys和hvals命令" class="headerlink" title="4、hkeys和hvals命令"></a>4、hkeys和hvals命令</h2><ol><li><code>hkeys key</code>：获取 <em>key</em> 所有的键</li><li><code>hvals key</code>：获取 <em>key</em> 多有的值</li></ol><h2 id="5、hincrby和hincrbyfloat命令"><a href="#5、hincrby和hincrbyfloat命令" class="headerlink" title="5、hincrby和hincrbyfloat命令"></a>5、hincrby和hincrbyfloat命令</h2><ol><li><code>hincrby key field increment</code>：给 <em>key</em> 对应的键值加上 <em>increment</em> ，但是键对应的值只能为数字，否则会报错</li><li><code>hincrbyfloat key field increment</code>：给 <em>key</em> 对应的键值加上 <em>increment</em> ，<em>increment</em> 可以为浮点数</li></ol><h2 id="6、hsetnx命令"><a href="#6、hsetnx命令" class="headerlink" title="6、hsetnx命令"></a>6、hsetnx命令</h2><ol><li><code>hsetnx key field value</code>：给 <em>key</em> 设置键值，但是这个键必须不存在，否则会报错</li></ol><h1 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="1、sadd命令"><a href="#1、sadd命令" class="headerlink" title="1、sadd命令"></a>1、sadd命令</h3><ol><li><code>sadd key member [member ...]</code>：往 <em>key</em> 里面添加成员，可以添加多个，但不能重复</li></ol><h3 id="2、smembers命令"><a href="#2、smembers命令" class="headerlink" title="2、smembers命令"></a>2、smembers命令</h3><ol><li><code>smembers key</code>：获取 <em>key</em> 全部的成员</li></ol><h3 id="3、sismember命令"><a href="#3、sismember命令" class="headerlink" title="3、sismember命令"></a>3、sismember命令</h3><ol><li><code>sismember key member</code>：查看 <em>key</em> 是否有成员 <em>member</em> ，若没有则返回 0，有则返回 1</li></ol><h3 id="4、srem命令"><a href="#4、srem命令" class="headerlink" title="4、srem命令"></a>4、srem命令</h3><ol><li><code>srem key member [member ...]</code>：删除 <em>key</em> 里面的成员，可以删除多个</li></ol><h3 id="5、scard命令"><a href="#5、scard命令" class="headerlink" title="5、scard命令"></a>5、scard命令</h3><ol><li><code>scard key</code>：获取 <em>key</em> 里面的成员个数</li></ol><h3 id="6、srandmember命令"><a href="#6、srandmember命令" class="headerlink" title="6、srandmember命令"></a>6、srandmember命令</h3><ol><li><code>srandmember key [count]</code>：随机获取 <em>key</em> 里面的 <em>count</em> 个成员，成员不删除</li></ol><h3 id="7、spop命令"><a href="#7、spop命令" class="headerlink" title="7、spop命令"></a>7、spop命令</h3><ol><li><code>spop key [count]</code>：随机弹出 <em>key</em> 里面 <em>count</em> 个值，成员会删除</li></ol><h3 id="8、smove命令"><a href="#8、smove命令" class="headerlink" title="8、smove命令"></a>8、smove命令</h3><ol><li><code>smove source destination member</code>：从 <code>source</code> 中移动成员到 <code>destination</code> 中</li></ol><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="1、差集运算-sdiff"><a href="#1、差集运算-sdiff" class="headerlink" title="1、差集运算(sdiff)"></a>1、差集运算(sdiff)</h3><ol><li><code>sdiff key [key ...]</code>：获取两个 <em>key</em> 之间的差集，如 A-B，获取 A 中有的，B 中没有的</li></ol><h3 id="2、并集运算-sunion"><a href="#2、并集运算-sunion" class="headerlink" title="2、并集运算(sunion)"></a>2、并集运算(sunion)</h3><ol><li><code>sunion key [key ...]</code>：获取两个 <em>key</em> 之间的并集</li></ol><h3 id="3、交集运算-sinter和sintercard"><a href="#3、交集运算-sinter和sintercard" class="headerlink" title="3、交集运算(sinter和sintercard)"></a>3、交集运算(sinter和sintercard)</h3><ol><li><code>sinter key [key ...]</code>：获取两个 <em>key</em> 之间的交集</li><li><code>sintercard numkeys key [key ...] [LIMIT limit]</code>：获取 <em>numkeys</em> 个 <em>key</em> 的交集元素个数，后面的 <em>limit</em> 表示显示几个</li></ol><h1 id="ZSet类型"><a href="#ZSet类型" class="headerlink" title="ZSet类型"></a>ZSet类型</h1><h2 id="1、zadd命令"><a href="#1、zadd命令" class="headerlink" title="1、zadd命令"></a>1、zadd命令</h2><ol><li><code>zadd key [NX|XX] [GT|LT] [CH] [INCR] score member [score member ...]</code>：往 <em>key</em> 里面添加成员和分数</li></ol><h2 id="2、zrange命令"><a href="#2、zrange命令" class="headerlink" title="2、zrange命令"></a>2、zrange命令</h2><ol><li><code>zrange key start stop [byscore|bylex] [rev] [LIMIT offset count] [WITHSCORES]</code>：遍历 <em>key</em> ，<em>withscores</em> 表示可以带着分数</li></ol><h2 id="3、zrevrange命令"><a href="#3、zrevrange命令" class="headerlink" title="3、zrevrange命令"></a>3、zrevrange命令</h2><ol><li><code>zrevrange key start stop [WITHSCORES]</code>：反向遍历 <em>key</em> ，其他的和 <code>zrange</code> 一样</li></ol><h2 id="4、zrangebyscore命令"><a href="#4、zrangebyscore命令" class="headerlink" title="4、zrangebyscore命令"></a>4、zrangebyscore命令</h2><ol><li><code>zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</code>：遍历 <em>key</em> ，从规定的最小值到最大值，即 <code>&gt;=,&lt;=</code> ，可以用 <em>offset</em> 指定返回的数量，如果 <em>min</em> 和 <em>max</em> 的左边带有<code>(</code>，如 <code>(min</code> 或者 <code>(max</code> ，表示 <code>&gt;</code> 或者 <code>&lt;</code></li></ol><h2 id="5、zscore命令"><a href="#5、zscore命令" class="headerlink" title="5、zscore命令"></a>5、zscore命令</h2><ol><li><code>zscore key member</code>：获取 <em>key</em> 对应成员的分数</li></ol><h2 id="6、zcard命令"><a href="#6、zcard命令" class="headerlink" title="6、zcard命令"></a>6、zcard命令</h2><ol><li><code>zcard key</code>：获取 <em>key</em> 的成员个数</li></ol><h2 id="7、zrem命令"><a href="#7、zrem命令" class="headerlink" title="7、zrem命令"></a>7、zrem命令</h2><ol><li><code>zrem key member [member ...]</code>：删除 <em>key</em> 的成员，可以删除多个</li></ol><h2 id="8、zincrby命令"><a href="#8、zincrby命令" class="headerlink" title="8、zincrby命令"></a>8、zincrby命令</h2><ol><li><code>zincrby key increment member</code>：给 <em>key</em> 对应的成员分数增加 <em>increment</em></li></ol><h2 id="9、zcount命令"><a href="#9、zcount命令" class="headerlink" title="9、zcount命令"></a>9、zcount命令</h2><ol><li><code>zcount key min max</code>：获得 <em>key</em> 在 <em>min</em> 到 <em>max</em> 范围内的成员个数</li></ol><h2 id="10、zmpop命令"><a href="#10、zmpop命令" class="headerlink" title="10、zmpop命令"></a>10、zmpop命令</h2><ol><li><code>zmpop numkeys key [key ...] MIN|MAX [COUNT count]</code>：从 <em>numkeys</em> 个 <em>key</em> 中弹出最小(MIN)或最大(MAX)分数的成员，弹出 <em>count</em> 个</li></ol><h2 id="11、zrank命令"><a href="#11、zrank命令" class="headerlink" title="11、zrank命令"></a>11、zrank命令</h2><ol><li><code>zrank key member [WITHSCORES]</code>：正序获取 <em>key</em> 对应成员的下标值</li></ol><h2 id="12、zrevrank命令"><a href="#12、zrevrank命令" class="headerlink" title="12、zrevrank命令"></a>12、zrevrank命令</h2><ol><li><code>zrevrank key member [WITHSCORES]</code>：逆序获取 <em>key</em> 对应成员的下标值</li></ol><h1 id="Bitmap类型"><a href="#Bitmap类型" class="headerlink" title="Bitmap类型"></a>Bitmap类型</h1><p><em><strong>*************************************底层是 String*********************************</strong></em></p><h2 id="1、setbit命令"><a href="#1、setbit命令" class="headerlink" title="1、setbit命令"></a>1、setbit命令</h2><ol><li><code>setbit key offset value</code>：设置 <em>key</em> 的偏移量的值为多少，<em>offset</em> 从 0 开始，<strong><em>value</em> 只能为 0 或 1</strong></li></ol><h2 id="2、getbit命令"><a href="#2、getbit命令" class="headerlink" title="2、getbit命令"></a>2、getbit命令</h2><ol><li><code>getbit key offset</code>：获得 <em>key</em> 偏移量 <em>offset</em> 的值</li></ol><h2 id="3、strlen命令"><a href="#3、strlen命令" class="headerlink" title="3、strlen命令"></a>3、strlen命令</h2><ol><li><code>strlen key</code>：获得 <em>key</em> 占据几个字节，不是获得字符串的长度，超过 8 位后自己按照 8 位一组一byte再扩容</li></ol><h2 id="4、bitcount命令"><a href="#4、bitcount命令" class="headerlink" title="4、bitcount命令"></a>4、bitcount命令</h2><ol><li><code>bitcount key [start end [BYTE|BIT]]</code>：获取  <em>key</em> 里面从 <em>start</em> 位到 <em>end</em> 位含有 1 的位数，默认是 <em>BYTE</em> 单位，最好是用 <em>BIT</em> 作为单位</li></ol><h2 id="5、bitop命令"><a href="#5、bitop命令" class="headerlink" title="5、bitop命令"></a>5、bitop命令</h2><ol><li><code>BITOP AND|OR|XOR|NOT destkey key [key ...]</code>：让多个 <em>key</em> 可以进行 <em><strong>位运算</strong></em> (与  或  异或  非)，结果给 <em>destkey</em></li></ol><h1 id="HyperLogLog类型"><a href="#HyperLogLog类型" class="headerlink" title="HyperLogLog类型"></a>HyperLogLog类型</h1><p><em><strong>*************************************基数统计，底层是String*********************************</strong></em></p><h2 id="1、pfadd命令"><a href="#1、pfadd命令" class="headerlink" title="1、pfadd命令"></a>1、pfadd命令</h2><ol><li><code>pfadd key [element [element ...]]</code>：往 <em>key</em> 里面插入 <em>element</em> 元素</li></ol><h2 id="2、pfcount命令"><a href="#2、pfcount命令" class="headerlink" title="2、pfcount命令"></a>2、pfcount命令</h2><ol><li><code>pfcount key [key ...]</code>：去掉重复的元素后，统计剩下的元素个数，多个 <em>key</em> ，会统计总的去掉重复元素之后的个数</li></ol><h2 id="3、pfmerge命令"><a href="#3、pfmerge命令" class="headerlink" title="3、pfmerge命令"></a>3、pfmerge命令</h2><ol><li><code>pfmerge destkey [sourcekey [sourcekey ...]]</code>：合并多个 <em>sourcekey</em> 到 <em>destkey</em> 中，并去掉重复元素</li></ol><h1 id="GEO类型"><a href="#GEO类型" class="headerlink" title="GEO类型"></a>GEO类型</h1><p><em><strong>*************************************底层是ZSet*********************************</strong></em></p><p><em><strong>**************************中文乱码，在redis-cli后面加上–raw*************************</strong></em></p><h2 id="1、geoadd命令"><a href="#1、geoadd命令" class="headerlink" title="1、geoadd命令"></a>1、geoadd命令</h2><ol><li><code>geoadd key [NX|XX] [CH] longitude latitude member [longitude latitude member ...]</code>：<em>longitude</em> 经度，<em>latitude</em> 纬度，<em>member</em> 位置名称</li></ol><h2 id="2、geopos命令"><a href="#2、geopos命令" class="headerlink" title="2、geopos命令"></a>2、geopos命令</h2><ol><li><code>geopos key [member [member ...]]</code>：返回经纬度</li></ol><h2 id="3、geohash命令"><a href="#3、geohash命令" class="headerlink" title="3、geohash命令"></a>3、geohash命令</h2><ol><li><code>geohash key [member [member ...]]</code>：返回经纬度坐标的geohash表示</li></ol><h2 id="4、geodist命令"><a href="#4、geodist命令" class="headerlink" title="4、geodist命令"></a>4、geodist命令</h2><ol><li><code>geodist key member1 member2 [M|KM|FT|MI]</code>：两个位置之间的距离，后面跟单位 <em>KM</em> 千米，<em>M</em> 米，<em>FT</em> 英尺，<em>MI</em> 英里</li></ol><h2 id="5、georadius命令"><a href="#5、georadius命令" class="headerlink" title="5、georadius命令"></a>5、georadius命令</h2><ol><li><code>georadius key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</code>：以给定的经纬度为中心，返回键包含的位置元素当中，与中心的距离不超过给定最大距离(<em><strong>radius</strong></em>)的所有位置元素，<em><strong>withdist</strong></em>：返回位置元素的同时，将位置元素与中心之间的距离也一并返回，<em><strong>withcoord</strong></em>：将位置元素的经度与纬度一并返回，<em><strong>withhash</strong></em>：以52位有符号整数的形式，返回位置元素经过原始<em><strong>geohash</strong></em>编码的有序集合分值，<em><strong>count</strong></em>：限定返回的记录数</li></ol><h2 id="6、georadiusbymember命令"><a href="#6、georadiusbymember命令" class="headerlink" title="6、georadiusbymember命令"></a>6、georadiusbymember命令</h2><ol><li><code>georadiusbymember key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key|STOREDIST key]</code>：根据位置名称查找，和 <em><strong>georadius</strong></em> 的用法差不多</li></ol><h1 id="Stream类型"><a href="#Stream类型" class="headerlink" title="Stream类型"></a>Stream类型</h1><h2 id="队列相关指令"><a href="#队列相关指令" class="headerlink" title="队列相关指令"></a>队列相关指令</h2><h3 id="1、xadd命令"><a href="#1、xadd命令" class="headerlink" title="1、xadd命令"></a>1、xadd命令</h3><ol><li><code>xadd key [NOMKSTREAM] [MAXLEN|MINID [=|~] threshold [LIMIT count]] *|id field value [field value ...]</code>：添加消息到队列末尾，* 表示自动生成 <em><strong>MessageID</strong></em>，若不加 <em>，则要自己手动加 <em><strong>ID</strong></em>，后面顺序跟着一堆业务 <em><strong>field</strong></em>，</em><strong>value</strong>*</li></ol><h3 id="2、xtrim命令"><a href="#2、xtrim命令" class="headerlink" title="2、xtrim命令"></a>2、xtrim命令</h3><ol><li><code>xtrim key MAXLEN|MINID [=|~] threshold [LIMIT count]</code>：对 <em><strong>Stream</strong></em> 的长度进行截取，<em><strong>maxlen</strong></em> 允许的最大长度，<em><strong>minid</strong></em> 允许的最小 <em><strong>id</strong></em></li></ol><h3 id="3、xdel命令"><a href="#3、xdel命令" class="headerlink" title="3、xdel命令"></a>3、xdel命令</h3><ol><li><code>xdel key id [id ...]</code>：删除 <em><strong>key</strong></em> 对应的 <em><strong>id</strong></em></li></ol><h3 id="4、xlen命令"><a href="#4、xlen命令" class="headerlink" title="4、xlen命令"></a>4、xlen命令</h3><ol><li><code>xlen key</code>：获取 <em><strong>key</strong></em> 里面成员的数量</li></ol><h3 id="5、xrange命令"><a href="#5、xrange命令" class="headerlink" title="5、xrange命令"></a>5、xrange命令</h3><ol><li><code>xrange key start end [COUNT count]</code>：<em><strong>start</strong></em> 表示开始值，<code>-</code>代表最小值，<em><strong>end</strong></em> 表示结束值，<code>+</code> 代表最大值，<em><strong>count</strong></em> 代表最多可以获取多少个值</li></ol><h3 id="6、xrevrange命令"><a href="#6、xrevrange命令" class="headerlink" title="6、xrevrange命令"></a>6、xrevrange命令</h3><ol><li><code>xrevrange key end start [COUNT count]</code>：<em><strong>end</strong></em> 取 <code>+</code>，<em><strong>start</strong></em> 取 <code>-</code></li></ol><h3 id="7、xread命令"><a href="#7、xread命令" class="headerlink" title="7、xread命令"></a>7、xread命令</h3><ol><li><code>xread [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</code>：<em><strong>count</strong></em> 最多读取多少条消息，<em><strong>block</strong></em> 是否已阻塞的方式读取消息，默认不阻塞，如果 <code>milliseconds</code> 设置为 0，表示永远阻塞，***$*** 表示从尾，<em><strong>0</strong></em> 表示从头</li></ol><h2 id="消费组相关指令"><a href="#消费组相关指令" class="headerlink" title="消费组相关指令"></a>消费组相关指令</h2><h3 id="1、xgroup-create指令"><a href="#1、xgroup-create指令" class="headerlink" title="1、xgroup create指令"></a>1、xgroup create指令</h3><ol><li><code>xgroup create key group id|$ [MKSTREAM] [ENTRIESREAD entries-read]</code>：用于创建消费者组</li></ol><h3 id="2、xreadgroup命令"><a href="#2、xreadgroup命令" class="headerlink" title="2、xreadgroup命令"></a>2、xreadgroup命令</h3><ol><li><code>GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] id [id ...]</code>：<code>&gt;</code> 表示从第一条尚未被消费的消息开始读取，消费组 <em>group</em> 内的消费者 <em>consumer</em> 从 <em>key</em> 消息队列中读取所有消息</li></ol><h3 id="3、xpending命令"><a href="#3、xpending命令" class="headerlink" title="3、xpending命令"></a>3、xpending命令</h3><ol><li><code>xpending key group [[IDLE min-idle-time] start end count [consumer]]</code>：查询每个消费组内所有消费者(已读取，但尚未确认)的消息，查看某个消费者具体读了哪些数据</li></ol><h3 id="4、xack命令"><a href="#4、xack命令" class="headerlink" title="4、xack命令"></a>4、xack命令</h3><ol><li><code>xack key group id [id ...]</code>：向消息队列确认消息处理已完成</li></ol><h3 id="5、xinfo-stream命令"><a href="#5、xinfo-stream命令" class="headerlink" title="5、xinfo stream命令"></a>5、xinfo stream命令</h3><ol><li><code>xinfo stream key [FULL [COUNT count]]</code>：用于打印 Stream\Consumer\Group的详细信息</li></ol><h1 id="redis客户端"><a href="#redis客户端" class="headerlink" title="redis客户端"></a>redis客户端</h1><h2 id="1、Jedis"><a href="#1、Jedis" class="headerlink" title="1、Jedis"></a>1、Jedis</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>在springboot中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   使用 jedis 作为 redis客户端    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试jedis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.65.128&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">        <span class="comment">// 选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        keys.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="jedis连接池"><a href="#jedis连接池" class="headerlink" title="jedis连接池"></a>jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis直连方式</p><h3 id="连接池配置"><a href="#连接池配置" class="headerlink" title="连接池配置"></a>连接池配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">// 最大连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最大空闲连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最小空闲连接数</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 等待时长</span></span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="comment">// 配置连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,</span><br><span class="line">                <span class="string">&quot;192.168.65.128&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;111111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试方法处，直接调用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.65.128&quot;, 6379);</span></span><br><span class="line">    <span class="comment">// 连接处创建 Jedis</span></span><br><span class="line">    jedis = JedisConnectFactory.getJedis();</span><br><span class="line">    <span class="comment">// 设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">    <span class="comment">// 选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、SpringDataRedis"><a href="#2、SpringDataRedis" class="headerlink" title="2、SpringDataRedis"></a>2、SpringDataRedis</h2><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   连接池依赖(commons-pool)    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>写入配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.65</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">111111</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure></li><li><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h3><p>对redis配置之后，存入对象就不会以字节的形式表示出来了，实现了序列化和反序列化的重新配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 redisTemplate 对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 创建 JSON 序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置 key 的序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置 value 的序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-StringRedisTemplate"><a href="#使用-StringRedisTemplate" class="headerlink" title="使用 StringRedisTemplate"></a>使用 StringRedisTemplate</h3><p>StringRedisTemplate只能使用&lt;String, String&gt;的泛型，但是可以手动序列化和反序列化，更为简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStringRedisTemplate</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:1&quot;</span>, userJson);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Objects.isNull(s)) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> objectMapper.readValue(s, User.class);</span><br><span class="line">            System.out.println(user1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-10大数据类型&quot;&gt;&lt;a href=&quot;#Redis-10大数据类型&quot; class=&quot;headerlink&quot; title=&quot;Redis 10大数据类型&quot;&gt;&lt;/a&gt;Redis 10大数据类型&lt;/h1&gt;&lt;p&gt;10大数据类型包括：&lt;strong&gt;String&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://kyajhl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://kyajhl.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://kyajhl.github.io/posts/test/"/>
    <id>https://kyajhl.github.io/posts/test/</id>
    <published>2023-08-08T02:39:21.000Z</published>
    <updated>2023-08-08T02:47:32.646Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里是测试博客</strong></p><p><img src="/posts/test/Vue%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="vue"></p><blockquote><p>这里终于可以上传图片了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;这里是测试博客&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/test/Vue%E5%8E%9F%E5%9E%8B%E9%93%BE.png&quot; alt=&quot;vue&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里终于可以上传图片了&lt;/p&gt;
</summary>
      
    
    
    
    <category term="心之所向" scheme="https://kyajhl.github.io/categories/%E5%BF%83%E4%B9%8B%E6%89%80%E5%90%91/"/>
    
    
    <category term="test" scheme="https://kyajhl.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="https://kyajhl.github.io/posts/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://kyajhl.github.io/posts/Markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2023-08-07T16:21:43.000Z</published>
    <updated>2023-08-08T03:14:05.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-基础语法"><a href="#Markdown-基础语法" class="headerlink" title="Markdown 基础语法"></a>Markdown 基础语法</h1><h2 id="1-Markdown-标题"><a href="#1-Markdown-标题" class="headerlink" title="(1) Markdown 标题"></a>(1) Markdown 标题</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br><span class="line"><span class="comment">#### 四级标题</span></span><br><span class="line"><span class="comment">##### 五级标题</span></span><br><span class="line"><span class="comment">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="2-Markdown-文本"><a href="#2-Markdown-文本" class="headerlink" title="(2) Markdown 文本"></a>(2) Markdown 文本</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">*斜体文本*</span></span><br><span class="line"><span class="string">**粗体文本**</span></span><br><span class="line"><span class="string">***斜粗体文本***</span></span><br><span class="line"><span class="string">_斜体文本_</span></span><br><span class="line"><span class="string">__粗体文本__</span></span><br><span class="line"><span class="string">___斜粗体文本___</span></span><br></pre></td></tr></table></figure><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><em><strong>斜粗体文本</strong></em></p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><em><strong>斜粗体文本</strong></em></p><h2 id="3-Markdown-列表"><a href="#3-Markdown-列表" class="headerlink" title="(3) Markdown 列表"></a>(3) Markdown 列表</h2><ul><li>无序列表，使用 <strong>星号</strong>(<em>****)、<strong>加号</strong>(</em><em>+<strong>)、</strong>减号*</em>(<strong>-</strong>) 加一个 <strong>空格</strong> 作为列表标记</li><li>有序列表，使用 <strong>数字</strong>再加上 (<strong>.</strong>) <strong>号</strong>，再加上一个 <strong>空格</strong> 作为列表标记</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">*</span> <span class="string">无序列表</span> <span class="number">1</span></span><br><span class="line"><span class="string">+</span> <span class="string">无序列表</span> <span class="number">2</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">无需列表</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">有序列表</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">有序列表</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">有序列表</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h3><ul><li><p>无序列表 1</p></li><li><p>无序列表 2</p><ul><li>无序列表 3</li></ul></li></ul><ol><li>有序列表 1</li><li>有序列表 2</li><li>有序列表 3</li></ol><h2 id="4-Markdown-链接"><a href="#4-Markdown-链接" class="headerlink" title="(4) Markdown 链接"></a>(4) Markdown 链接</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接名称</span>]<span class="string">(链接地址)</span></span><br><span class="line">[<span class="string">百度</span>]<span class="string">(https://www.baidu.com)</span></span><br><span class="line"></span><br><span class="line"><span class="string">或者</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;链接地址&gt;</span></span><br><span class="line"><span class="string">&lt;https://www.baidu.com&gt;</span></span><br></pre></td></tr></table></figure><h3 id="例如-2"><a href="#例如-2" class="headerlink" title="例如"></a>例如</h3><p><a href="https://www.baidu.com/">百度</a></p><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p><h2 id="5-Markdown-引用"><a href="#5-Markdown-引用" class="headerlink" title="(5) Markdown 引用"></a>(5) Markdown 引用</h2><p>引用的格式是在符号 <strong>&gt;</strong> 后面书写文字，或者加一个空格在书写文字</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt;这是一个引用</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">这是一个引用</span></span><br></pre></td></tr></table></figure><h3 id="例如-3"><a href="#例如-3" class="headerlink" title="例如"></a>例如</h3><blockquote><p>这是一个引用</p></blockquote><blockquote><p>这是一个引用</p></blockquote><h2 id="6-Markdown-分割线"><a href="#6-Markdown-分割线" class="headerlink" title="(6) Markdown 分割线"></a>(6) Markdown 分割线</h2><p>可以在一行中用 <strong>三个 -</strong> 或者 ***** 来建立一个分割线，同时需要在分割线的上面空一行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">这是一个分割线</span></span><br><span class="line"></span><br><span class="line"><span class="string">或者</span></span><br><span class="line"></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">*****</span></span><br></pre></td></tr></table></figure><h3 id="例如-4"><a href="#例如-4" class="headerlink" title="例如"></a>例如</h3><hr><hr><hr><hr><hr><hr><hr><hr><h2 id="7-Markdown-删除线"><a href="#7-Markdown-删除线" class="headerlink" title="(7) Markdown 删除线"></a>(7) Markdown 删除线</h2><p>删除线的使用，需要在删除的文字 <strong>前后</strong> 各使用 <strong>两个</strong> <strong>~</strong> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">~~这是要删除的内容~~</span></span><br></pre></td></tr></table></figure><h3 id="例如-5"><a href="#例如-5" class="headerlink" title="例如"></a>例如</h3><p><del>这段内容要被删除了</del></p><h2 id="8-Markdown-下划线"><a href="#8-Markdown-下划线" class="headerlink" title="(8) Markdown 下划线"></a>(8) Markdown 下划线</h2><p>下划线的使用，在需要添加下划线的文字首部和尾部加上 <code>&lt;u&gt;文本&lt;/u&gt; </code>，如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;u&gt;这行文字已被添加下划线&lt;/u&gt;</span></span><br></pre></td></tr></table></figure><h3 id="例如-6"><a href="#例如-6" class="headerlink" title="例如"></a>例如</h3><p><u>这行文字已被添加下划线</u></p><h2 id="9-Markdown-表格"><a href="#9-Markdown-表格" class="headerlink" title="(9) Markdown 表格"></a>(9) Markdown 表格</h2><p>表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行，如果想调整表格的左对齐、右对齐、居中对齐：</p><ul><li><code>:-</code>   将表头及单元格的内容 <strong>左对齐</strong></li><li><code>:-:</code> 将表头及单元格的内容 <strong>居中对齐</strong></li><li><code>-:</code>   将表头及单元格的内容 <strong>右对齐</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|第一列|第二列|第三列|</span></span><br><span class="line"><span class="string">|:-|:-:|-:|</span></span><br><span class="line"><span class="string">|你好|hello</span> <span class="string">world|学</span> <span class="string">Java</span> <span class="string">，狠狠赚一笔|</span></span><br></pre></td></tr></table></figure><h3 id="例如-7"><a href="#例如-7" class="headerlink" title="例如"></a>例如</h3><table><thead><tr><th align="left">第一列</th><th align="center">第二列</th><th align="right">第三列</th></tr></thead><tbody><tr><td align="left">你好</td><td align="center">hello world</td><td align="right">学 Java ，狠狠赚一笔</td></tr></tbody></table><table><thead><tr><th>第一列</th><th>第二列</th><th>第三列</th></tr></thead><tbody><tr><td>你好</td><td>hello world</td><td>学 Java ，狠狠赚一笔</td></tr></tbody></table><h2 id="10-Markdown-图片"><a href="#10-Markdown-图片" class="headerlink" title="(10) Markdown 图片"></a>(10) Markdown 图片</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">![</span><span class="string">图片名称](图片地址)</span></span><br><span class="line"><span class="type">![Vue</span><span class="string">原型链](C:\Users\13627\Desktop\Vue原型链.png)</span></span><br><span class="line"></span><br><span class="line"><span class="type">![</span><span class="string">百度图标](https://www.baidu.com/favicon.ico)</span></span><br></pre></td></tr></table></figure><h3 id="例如-8"><a href="#例如-8" class="headerlink" title="例如"></a>例如</h3><p><img src="/posts/Markdown%E8%AF%AD%E6%B3%95/Vue%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="Vue原型链"></p><p><img src="https://www.baidu.com/favicon.ico" alt="百度图标"></p><h2 id="11-Markdown-脚注"><a href="#11-Markdown-脚注" class="headerlink" title="(11) Markdown 脚注"></a>(11) Markdown 脚注</h2><p>脚注是对文本的备注说明，脚注与链接的区别，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">链接：[文字](链接)</span></span><br><span class="line"></span><br><span class="line"><span class="string">脚注：文字[^脚注名字]</span></span><br><span class="line">[<span class="string">^脚注名字</span>]<span class="string">:</span> <span class="string">这是一个脚注</span></span><br></pre></td></tr></table></figure><h3 id="例如-9"><a href="#例如-9" class="headerlink" title="例如"></a>例如</h3><p>链接：<a href="https://www.baidu.com/">百度</a></p><p>脚注：百度<a href="666">^起源</a>     创业<a href="%E5%88%9B%E4%B8%9A%EF%BC%9A%E5%8D%B3%E8%B5%9A%E9%92%B1">^1</a></p><h2 id="12-Markdown-代码块"><a href="#12-Markdown-代码块" class="headerlink" title="(12) Markdown 代码块"></a>(12) Markdown 代码块</h2><p>如果要引用代码块，用  <code> ``</code> 符号包裹起来即可，或者直接输入 <code>```</code> 后面加语言的名字，也可以不加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Markdown-高级语法"><a href="#Markdown-高级语法" class="headerlink" title="Markdown 高级语法"></a>Markdown 高级语法</h1><h2 id="1-Markdown-数学公式"><a href="#1-Markdown-数学公式" class="headerlink" title="(1) Markdown 数学公式"></a>(1) Markdown 数学公式</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$$</span></span><br><span class="line"><span class="string">这里写公式语法</span></span><br><span class="line"><span class="string">$$</span></span><br></pre></td></tr></table></figure><p>$$<br>H(D_2) &#x3D; -\left(\frac{2}{4}\log_2 \frac{2}{4} + \frac{2}{4}\log_2 \frac{2}{4}\right) &#x3D; 1<br>$$</p><p>$$<br>\ce{Hg^2+ -&gt;[I-] HgI2 -&gt;[I-] [Hg^{II}I4]^2-}<br>$$</p><p>$$<br>\begin{pmatrix}<br>  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \<br>  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \<br>  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>  1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \<br>  \end{pmatrix}<br>$$</p><h2 id="2-Markdown-TOC-Table-of-Content"><a href="#2-Markdown-TOC-Table-of-Content" class="headerlink" title="(2) Markdown TOC(Table of Content)"></a>(2) Markdown TOC(Table of Content)</h2><p>列出全部标题，通俗点说，就是一个小目录</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">TOC</span>] <span class="string">或者</span> [<span class="string">toc</span>]</span><br></pre></td></tr></table></figure><p>[TOC]</p><h2 id="3-Markdown-HTML"><a href="#3-Markdown-HTML" class="headerlink" title="(3) Markdown HTML"></a>(3) Markdown HTML</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display:block;text-align:right;color:orangered;&quot;</span>&gt;</span>橙色居右<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display:block;text-align:center;color:orangered;&quot;</span>&gt;</span>橙色居中<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span style="display:block;text-align:right;color:orangered;">橙色居右</span><br><span style="display:block;text-align:center;color:orangered;">橙色居中</span></p><p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="7" face="黑体">color&#x3D;#0099ff size&#x3D;72 face&#x3D;”黑体”</font><br><font color="#00ffff" size="72">color&#x3D;#00ffff</font><br><font color="gray" size="72">color&#x3D;gray</font></p><h2 id="4-Markdown-转义"><a href="#4-Markdown-转义" class="headerlink" title="(4) Markdown 转义"></a>(4) Markdown 转义</h2><p>在 <code>Markdown</code> 编辑器里面使用了很多特殊符号来表示特定的意义，该特殊符号将不再显示，这个时候就需要转义字符——反斜杠，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\*\*转义特殊符号正常显示\*\*</span></span><br><span class="line"></span><br><span class="line"><span class="string">**无转义特殊符号无法正常显示**</span></span><br></pre></td></tr></table></figure><p>**转义特殊符号正常显示**</p><p><strong>无转义特殊符号无法正常显示</strong></p><h2 id="5-Markdown-URL"><a href="#5-Markdown-URL" class="headerlink" title="(5) Markdown URL"></a>(5) Markdown URL</h2><h2 id="6-Markdown-流程图和时序图"><a href="#6-Markdown-流程图和时序图" class="headerlink" title="(6) Markdown 流程图和时序图"></a>(6) Markdown 流程图和时序图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">玩家一-&gt;&gt;玩家二: 你好</span><br><span class="line">Note right of 玩家二: 正在思考</span><br><span class="line">玩家二--&gt;&gt;玩家一: 666</span><br></pre></td></tr></table></figure><h2 id="7-Markdown-复选框"><a href="#7-Markdown-复选框" class="headerlink" title="(7) Markdown 复选框"></a>(7) Markdown 复选框</h2><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 <code>todo-list</code> 等功能，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">默认没选：-</span> [ ] </span><br><span class="line"><span class="string">默认勾选：-</span> [<span class="string">x</span>] </span><br></pre></td></tr></table></figure><ul><li><p><input disabled type="checkbox"> 111</p></li><li><p><input checked disabled type="checkbox"> 222</p></li><li><p><input checked disabled type="checkbox"> 333</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown-基础语法&quot;&gt;&lt;a href=&quot;#Markdown-基础语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown 基础语法&quot;&gt;&lt;/a&gt;Markdown 基础语法&lt;/h1&gt;&lt;h2 id=&quot;1-Markdown-标题&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Markdown" scheme="https://kyajhl.github.io/categories/Markdown/"/>
    
    
    <category term="Markdown" scheme="https://kyajhl.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>mybatis动态sql</title>
    <link href="https://kyajhl.github.io/posts/mybatis%E5%8A%A8%E6%80%81sql/"/>
    <id>https://kyajhl.github.io/posts/mybatis%E5%8A%A8%E6%80%81sql/</id>
    <published>2023-08-06T16:57:15.000Z</published>
    <updated>2023-09-03T02:33:24.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h1><p>可以判断是否符合条件，再进行赋值查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseMap&quot;</span>&gt;</span></span><br><span class="line">select * </span><br><span class="line">    from tb_user</span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">        and user_name=#&#123;userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;realName != null&quot;</span>&gt;</span></span><br><span class="line">        and real_name=#&#123;realName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">        and age=#&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">        and id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="where-标签"><a href="#where-标签" class="headerlink" title="where 标签"></a>where 标签</h1><p>在写**<code>where</code><strong>的时候，为了保证 <strong><code>SQL</code></strong> 的的语法正确，在有</strong><code>and</code><strong>的情况下，可以用</strong><code>1=1</code><strong>表达式，若不想这么写的话，可以用</strong><code>where</code>**标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseMap&quot;</span>&gt;</span></span><br><span class="line">select * </span><br><span class="line">from tb_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">            and user_name=#&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;realName != null&quot;</span>&gt;</span></span><br><span class="line">            and real_name=#&#123;realName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            and age=#&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">            and id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="choose-标签"><a href="#choose-标签" class="headerlink" title="choose 标签"></a>choose 标签</h1><p>**<code>choose</code><strong>相当于Java中的</strong><code>switch</code><strong>语句，若第一个不成立，则执行第二个，若第二个也不成立，则执行最后的</strong><code>otherwise</code>**标签里面的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseMap&quot;</span>&gt;</span></span><br><span class="line">select * </span><br><span class="line">from tb_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">            and user_name = #&#123;userName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;realName != null&quot;</span>&gt;</span></span><br><span class="line">            and real_name = #&#123;realName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            order by id desc</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="set-标签"><a href="#set-标签" class="headerlink" title="set 标签"></a>set 标签</h1><p>可以去掉多余的 <strong><code>,</code></strong>  ，避免了**<code>SQL</code>**报错</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">update </span><br><span class="line">    tb_user</span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">        user_name = #&#123;userName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;realName != null&quot;</span>&gt;</span></span><br><span class="line">            real_name = #&#123;realName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where</span><br><span class="line">    id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="trim-标签"><a href="#trim-标签" class="headerlink" title="trim 标签"></a>trim 标签</h1><p><strong><code>trim</code><strong>标签可以完成 <strong><code>where</code></strong> 或者 <strong><code>set</code></strong> 标签的功能，</strong><code>prefix</code><strong>表示前缀为</strong>where</strong>标签，**<code>prefixOverrides</code><strong>表示去掉前面多余的</strong>and**</p><ul><li>第一种</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseMap&quot;</span>&gt;</span></span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND | OR&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">        and user_name = #&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;realName != null&quot;</span>&gt;</span></span><br><span class="line">            and real_name = #&#123;realName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            and age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**<code>suffixOverrides</code>**表示去掉后面多余的 <strong><code>,</code></strong></p><ul><li>第二种</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">update</span><br><span class="line">    tb_user</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">        user_name = #&#123;userName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;realName != null&quot;</span>&gt;</span></span><br><span class="line">            real_name = #&#123;realName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where</span><br><span class="line">    id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="forEach-标签"><a href="#forEach-标签" class="headerlink" title="forEach 标签"></a>forEach 标签</h1><p><strong><code>forEach</code></strong> 标签可以对集合进行遍历，**<code>open</code><strong>表示开始的括号，</strong><code>close</code><strong>表示最后的括号，</strong><code>separator</code><strong>表示用 <strong><code>,</code></strong> 分割，</strong><code>item</code>**表示每一个元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseMap&quot;</span>&gt;</span></span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ids != null&quot;</span>&gt;</span></span><br><span class="line">        id in</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">                #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="bind-标签"><a href="#bind-标签" class="headerlink" title="bind 标签"></a>bind 标签</h1><p>**<code>bind</code><strong>标签允许在</strong><code>OGNL</code>**表达式以外创建一个变量，将该变量绑定到上下文中，可以供后续使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;bind name=&quot;userNameLike&quot; value=&quot;&#x27;%&#x27;+_parameter.getUserName()+&#x27;%&#x27;&quot;/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;userNameLike&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + userName + &#x27;%&#x27;&quot;</span>/&gt;</span></span><br><span class="line">select *</span><br><span class="line">from tb_user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span></span><br><span class="line">        user_name like #&#123;userNameLike&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;if-标签&quot;&gt;&lt;a href=&quot;#if-标签&quot; class=&quot;headerlink&quot; title=&quot;if 标签&quot;&gt;&lt;/a&gt;if 标签&lt;/h1&gt;&lt;p&gt;可以判断是否符合条件，再进行赋值查询&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://kyajhl.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="mybatis" scheme="https://kyajhl.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>吐槽</title>
    <link href="https://kyajhl.github.io/posts/%E5%90%90%E6%A7%BD/"/>
    <id>https://kyajhl.github.io/posts/%E5%90%90%E6%A7%BD/</id>
    <published>2023-08-05T16:57:15.000Z</published>
    <updated>2023-09-03T02:56:24.376Z</updated>
    
    <content type="html"><![CDATA[<p>还在部署博客平台，艹了，简直日了狗</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;还在部署博客平台，艹了，简直日了狗&lt;/p&gt;
</summary>
      
    
    
    
    <category term="心之所向" scheme="https://kyajhl.github.io/categories/%E5%BF%83%E4%B9%8B%E6%89%80%E5%90%91/"/>
    
    
    <category term="随笔" scheme="https://kyajhl.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
